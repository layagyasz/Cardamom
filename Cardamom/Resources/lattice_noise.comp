#version 430 core

#define HASH_SPACE 256
#define KERNEL_SIZE 64

#define SURFACE_PLANE 0
#define SURFACE_CYLINDER 1
#define SURFACE_SPHERE 2

#define CHANNEL_RED 1
#define CHANNEL_GREEN 2
#define CHANNEL_BLUE 4
#define CHANNEL_ALPHA 8

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D in_texture;
layout(rgba32f, binding = 1) uniform image2D out_texture;

layout(location=0) uniform float frequency;
layout(location=1) uniform float lacunarity;
layout(location=2) uniform int octaves;
layout(location=3) uniform float persistence;
layout(location=4) uniform float bias;
layout(location=5) uniform float amplitude;
layout(location=6) uniform vec3 offset;
layout(location=7) uniform int surface;
layout(location=8) uniform vec3 scale;
layout(location=9) uniform int channel;

layout(location=10) uniform int hash_lookup[HASH_SPACE];
layout(location=266) uniform vec3 kernel[KERNEL_SIZE];

float fade(float x) {
	return x * x * x * (x * (x * 6 - 15) + 10); 
}

float linear(vec3 u) {
	return (1 - u.x) * (1 - u.y) * (1 - u.z);
}

float gradient(vec3 u, vec3 v) {
	return dot(u, v);
}

int hash(int x, int y, int z) {
	return (KERNEL_SIZE - 1) 
		& hash_lookup[
			(hash_lookup[
				(hash_lookup[
					x & (HASH_SPACE - 1)
				] + (y & (HASH_SPACE - 1))) % HASH_SPACE
			] + (z & (HASH_SPACE - 1))) % HASH_SPACE
		];
}

float generate_octave(vec3 position) {
	int gx = int(floor(position.x));
	int gy = int(floor(position.y));
	int gz = int(floor(position.z));
	float dx = position.x - gx;
	float dy = position.y - gy;
	float dz = position.z - gz;
	float a = fade(dx);
	float b = fade(dy);
	float c = fade(dz);

	float o = linear(vec3(a, b, c)) * gradient(vec3(dx, dy, dz), kernel[hash(gx, gy, gz)]);
	float p = linear(vec3(1 - a, b, c)) * gradient(vec3(dx - 1, dy, dz), kernel[hash(gx + 1, gy, gz)]);
	float q = linear(vec3(a, 1 - b, c)) * gradient(vec3(dx, dy - 1, dz), kernel[hash(gx, gy + 1, gz)]);
	float r = linear(vec3(1 - a, 1 - b, c)) * gradient(vec3(dx - 1, dy - 1, dz), kernel[hash(gx + 1, gy + 1, gz)]);

	float s = linear(vec3(a, b, 1 - c)) * gradient(vec3(dx, dy, dz - 1), kernel[hash(gx, gy, gz + 1)]);
	float t = linear(vec3(1 - a, b, 1 - c)) * gradient(vec3(dx - 1, dy, dz - 1), kernel[hash(gx + 1, gy, gz + 1)]);
	float u = linear(vec3(a, 1 - b, 1 - c)) * gradient(vec3(dx, dy - 1, dz - 1), kernel[hash(gx, gy + 1, gz + 1)]);
	float v = 
		linear(vec3(1 - a, 1 - b, 1 - c))
		* gradient(vec3(dx - 1, dy - 1, dz - 1), kernel[hash(gx + 1, gy + 1, gz + 1)]);

	return o + p + q + r + s + t + u + v;
}

float generate(vec3 position) {
	float total = 0;
    float a = amplitude;
    float max = 0;
	float f = frequency;
    for (int i = 0; i < octaves; ++i)
    {
        total += a * generate_octave(f * position);
        max += a;
        a *= persistence;
        f *= lacunarity;
    }

    return total / max + bias;
}

vec3 map(vec2 pixel) {
	switch (surface) {
		case SURFACE_CYLINDER:
			float t = scale.x * (pixel.x + offset.x);
			return vec3(scale.z * cos(t), scale.z * sin(t), scale.y * (pixel.y + offset.y));
		case SURFACE_SPHERE:
			vec2 angle = scale.xy * (pixel + offset.xy);
			float sinTheta = sin(angle.y);
			return scale.z * vec3(cos(angle.x) * sinTheta, sin(angle.x) * sinTheta, cos(angle.y));
		default:
			return scale * (vec3(pixel, 0) + offset);
	}
}

void main() {
    ivec2 position = ivec2(gl_GlobalInvocationID.xy);
    vec4 current = imageLoad(in_texture, position);
	float v = clamp(generate(map(gl_GlobalInvocationID.xy)), 0, 1);
	vec4 new = 
		vec4(
			(channel & CHANNEL_RED) != 0 ? v : current.r,
			(channel & CHANNEL_GREEN) != 0 ? v : current.g,
			(channel & CHANNEL_BLUE) != 0 ? v : current.b,
			(channel & CHANNEL_ALPHA) != 0 ? v : current.a);
    imageStore(out_texture, position, new);
}