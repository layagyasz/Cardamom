#version 430 core

#define HASH_SPACE 256
#define KERNEL_SIZE 64

#define CHANNEL_RED 1
#define CHANNEL_GREEN 2
#define CHANNEL_BLUE 4
#define CHANNEL_ALPHA 8

layout(local_size_x = 1, local_size_y = 1, local_size_z = 1) in;
layout(rgba32f, binding = 0) uniform image2D in_texture;
layout(rgba32f, binding = 1) uniform image2D out_texture;

layout(location=0) uniform float frequency;
layout(location=1) uniform float lacunarity;
layout(location=2) uniform int octaves;
layout(location=3) uniform float persistence;
layout(location=4) uniform float bias;
layout(location=5) uniform float amplitude;
layout(location=6) uniform vec2 offset;
layout(location=7) uniform int channel;

layout(location=8) uniform int hash_lookup[HASH_SPACE];
layout(location=264) uniform vec3 kernel[KERNEL_SIZE];

float fade(float x) {
	return x * x * x * (x * (x * 6 - 15) + 10); 
}

float linear(vec2 u) {
	return (1 - u.x) * (1 - u.y);
}

float gradient(vec2 u, vec3 v) {
	return dot(u, v.xy);
}

int hash(ivec2 v) {
	return (KERNEL_SIZE - 1) 
		& hash_lookup[(hash_lookup[v.x & (HASH_SPACE - 1)] + (v.y & (HASH_SPACE - 1))) % HASH_SPACE];
}

float generate_octave(vec2 position) {
	int gx = int(floor(position.x));
	int gy = int(floor(position.y));
	float dx = position.x - gx;
	float dy = position.y - gy;
	float a = fade(dx);
	float b = fade(dy);

	float s = linear(vec2(a, b)) * gradient(vec2(dx, dy), kernel[hash(ivec2(gx, gy))]);
	float t = linear(vec2(1 - a, b)) * gradient(vec2(dx - 1, dy), kernel[hash(ivec2(gx + 1, gy))]);
	float u = linear(vec2(a, 1 - b)) * gradient(vec2(dx, dy - 1), kernel[hash(ivec2(gx, gy + 1))]);
	float v = linear(vec2(1 - a, 1 - b)) * gradient(vec2(dx - 1, dy - 1), kernel[hash(ivec2(gx + 1, gy + 1))]);

	return mix(mix(s, t, dx), mix(u, v, dx), dy);
}

float generate(vec2 position) {
	float total = 0;
    float a = amplitude;
    float max = 0;
	float f = frequency;
    for (int i = 0; i < octaves; ++i)
    {
        total += a * generate_octave(f * position);
        max += a;
        a *= persistence;
        f *= lacunarity;
    }

    return total / max + bias;
}

void main() {
    ivec2 position = ivec2(gl_GlobalInvocationID.xy);
    vec4 current = imageLoad(in_texture, position);
	float v = clamp(generate(gl_GlobalInvocationID.xy + offset), 0, 1);
	vec4 new = 
		vec4(
			(channel & CHANNEL_RED) != 0 ? v : current.r,
			(channel & CHANNEL_GREEN) != 0 ? v : current.g,
			(channel & CHANNEL_BLUE) != 0 ? v : current.b,
			(channel & CHANNEL_ALPHA) != 0 ? v : current.a);
    imageStore(out_texture, position, new);
}